!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t=t||self).mlodash=e()}(this,function(){"use strict";function t(t){return Object.prototype.toString.call(t)}function e(t,e){return Object.prototype.hasOwnProperty.call(t,e)}function n(e){return"[object Object]"===t(e)}function r(e){return"[object String]"===t(e)}function o(e){return"[object Function]"===t(e)}function s(e){return"[object Array]"===t(e)}function c(t,e){return t===e?0!==t||0!==e||1/t==1/e:t!=t&&e!=e}function i(t,n){if(c(t,n))return!0;if("object"!=typeof t||null===t||"object"!=typeof n||null===n)return!1;const r=Object.keys(t),o=Object.keys(n);if(r.length!==o.length)return!1;let s=0;for(;s<r.length;){if(!e(n,r[s])||!c(t[r[s]],n[r[s]]))return!1;s+=1}return!0}function l(t,n){return null!=t&&e(t,n)}function u(t,e){let r=0;if(s(t))for(;r<t.length;){if(!1===e(t[r],r,t))break;r+=1}else if(n(t)){const n=Object.keys(t);for(;r<n.length;){const o=n[r];if(!1===e(t[o],o,t))break;r+=1}}}function f(t,e){let n=-1;return u(t,(t,r,s)=>{if(o(e)){if(!0===e(t,r,s))return n=r,!1}else if(i(t,e))return n=r,!1}),n}const h=".".charCodeAt(0),a=/\\(\\)?/g,p=RegExp("[^.[\\]]+|\\[(?:([^\"'].*)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))","g");function g(t){const e=[];return t.charCodeAt(0)===h&&e.push(""),t.replace(p,(t,n,r,o)=>{let s=t;r?s=o.replace(a,"$1"):n&&(s=n.trim()),e.push(s)}),e}const b=Symbol("name"),y=Symbol("watchMap"),d=Symbol("eventMap");function j(t,e,n,r){const s=Object.getOwnPropertyDescriptor(t,e);if(s&&!1===s.configurable)return;const c=s&&s.get,l=s&&s.set;Object.defineProperty(t,e,{enumerable:!0,configurable:!0,get:()=>{return c?c.call(t):n},set:e=>{const s=c?c.call(t):n;i(e,s)||c&&!l||(l?l.call(t,e):n=e,o(r)&&r(s))}})}function m(t){const e=["event","state"];return-1===e.indexOf(t)||(console.error(`${e.join()} 是store对象的保留关键字，请勿声明使用`),!1)}class O{constructor(t,e){let c=(t=t||{}).event||[],i=t.getter||{},f=t.setter||{},h=t.method||{},a=t.state||{};this[b]=t.name,Object.defineProperty(this,"_$store",{get:()=>e}),this[d]=new Map,c=function(t,e){let r=0,o=arguments[2];if(s(t)){for(3!==arguments.length&&(o=t[0]);r<t.length;)o=e(o,t[r],r,t),r+=1;return o}if(n(t)){const n=Object.keys(t);for(3!==arguments.length&&(o=t[n[0]]);r<n.length;){const s=n[r];o=e(o,t[s],s,t),r+=1}return o}return o}(c,(t,e)=>(r(e)&&(t[e]=e),t),{}),Object.freeze(c),Object.defineProperty(this,"event",{get:()=>c});const p={};u(i,(t,e)=>{p[e]=p[e]||{},o(t)&&(p[e].get=()=>t.call(this))}),u(f,(t,e)=>{p[e]=p[e]||{},o(t)&&(p[e].set=(...e)=>t.apply(this,e))}),u(p,(t,e)=>{l(this,e)?console.error(`模块（${this[b]}）中出现重复的字段（key = ${e}），`+"请检查state, getter, setter, method"):m(e)&&Object.defineProperty(this,e,t)}),u(h,(t,e)=>{l(this,e)?console.error(`模块（${this[b]}）中出现重复的字段（key = ${e}），`+"请检查state, getter, setter, method"):m(e)&&o(t)&&Object.defineProperty(this,e,{get(){return(...e)=>t.apply(this,e)}})}),this.state={},u(a,(t,e)=>{l(this,e)?console.error(`模块（${this[name]}）中出现重复的字段（key = ${e}），`+"请检查state, getter, setter, method"):m(e)&&(j(this,e,t),this.state[e]=e)}),this[y]=new Map}on(t,e,n=null){this.event[t]&&o(e)&&(this[d].has(t)||this[d].set(t,[]),this[d].get(t).push({func:e,ctx:n}))}off(t,e){if(this[d].has(t))if(e){const n=this[d].get(t),r=f(n,t=>t.func===e);-1!==r&&n.splice(r,1)}else this[d].delete(t)}emit(t,...e){if(this.event[t]&&this[d].has(t)){u(this[d].get(t),t=>{try{t.func.apply(t.ctx,e)}catch(t){console.error(t)}})}}watch(t,e,s=null){if(!t||!r(t))return void console.error(`模块（${this[b]}）: watch第一个参数必填且必须是有效字符串`);if(!o(e))return void console.error(`模块（${this[b]}）: watch第二个参数必填且必须是函数`);const c=r(i=t)?g(i):[];var i;let l=c[0],h=this;if(c.length>1&&(l=c.splice(-1),!n(h=function(t,e,n){if(null==t)return n;if(!Array.isArray(e)){const n=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,r=/^\w*$/;e=function(t,e){const o=typeof t;return"number"==o||"boolean"==o||null==t||r.test(t)||!n.test(t)||null!=e&&t in Object(e)}(e,t)?[e]:g(e)}let r=0;const o=e.length;for(;null!=t&&r<o;)t=t[e[r]],r+=1;return r&&r===o?void 0===t?n:t:n}(this,c))))console.error(`模块（${this[b]}）中state[${c.join("][")}]不是object类型,`+"，不能被watch");else if(this[y].has(t)){const n=this[y].get(t);-1===f(n,t=>t.func===e)&&n.push({func:e,ctx:s})}else this[y].set(t,[{func:e,ctx:s}]),j(h,l,h[l],e=>{u(this[y].get(t),t=>{t.func.call(t.ctx,h[l],e,this._$store)})})}unWatch(t,e){if(this[y].has(t))if(e){const n=this[y].get(t),r=f(n,t=>t.func===e);-1!==r&&n.splice(r,1)}else this[y].delete(t)}}return function(t){const e={};return u(t,(t,n)=>{l(t,"name")?l(e,t.name)?console.error(`模块注册失败，模块名称重复: name=${t.name}`):e[t.name]=Object.freeze(new O(t,e)):console.error(`模块注册失败(${n})，缺失必要字段：name`)}),e}});
